주어진 배열은 크게 두 가지 종류로 나뉜다. 

1) 위치를 바꿔야 하는 부분

2) 위치를 바꿔도 되지 않는 부분

 

2)의 경우 처럼 위치를 바꿔도 되지 않는 부분은

오름차순으로 정렬했을 때의 위치와 일치하는 부분이다.

(입력 받았을 때 부터 제 위치를 찾은 경우)



1)의 경우에서 한번 사이클을 찾으면 

바꿔야 하는 부분의 모든 부분을 찾게 된다.

 

이 때 바꿔야 할 부분을 바꾸는 기본적인 방법은

가장 최솟값 하나를 선택해서 

그것과 계속 바꾸는 방법을 이용한다.



​이 때 2가지 case가 존재한다. 

1) 가장 최솟값이 바꿔야 할 부분에 속하는 경우

 

2) 가장 최솟값이 앞에서 설명한 

( 2)위치를 바꿔도 되지 않는 부분) 에 속하는 경우

 

﻿첫번째 case 같은 경우는 

10  2  8  5 를 예로 봤을 때

가장 최솟값인 2가 위치를 바꿔야 할 부분에 속한다.

따라서 2를 이용하여 계속 위치를 바꿔 나간다.



현재 2의 위치에는 5가 와야 하므로 

2와 5를 바꾼 (5)

10  5  8  2 가 되고

그 다음 2의 자리에는 10이 와야하므로 

2와 10을 바꾼다. ​(5+10)

2  5  8  10



그러면 총 힘을 쓴 것을 고려해보면

총 옮겨야 할 것들의 합인 

sum = 5+10

그리고 옮겨야 할것의 갯수를 cnt라고 하면

(cnt-1) * minimum(여기서는 최솟값인 2) 를 더해준다.



여기서 (cnt-1) 인 이유는

전체 옮겨야 할 갯수가 cnt일 때 여기서는

교환 횟수가 cnt-1이 되기 때문이다.

 



두번째 case 같은 경우는

예를 들어 

2 10 5 8 인 경우를 보면

바꿔야 할 부분은 10 5 8 인데 가장 최솟값은 2이다.

따라서 10 5 8 을 바꾸는 데 2를 이용한다.



그 중 2와 가장 먼저 바꿔야 할 부분은

바꿔야 할 부분에서 최솟값( 5 )과 임시로 바꾼다.



5 10 2 8    ​(5)

​그 다음 2의 위치에 와야할 것은 8 이므로

5 10 8 2 ​  (5 , 8)

​그 다음 2의 위치에 와야할 것은 10이다.

5 2 8 10   ​(5, 8+10)

그 다음 2의 위치에 와야할 것은 5이다.

2  5  8  10 ​  (5, 8+10+5)



​여기서 총 드는 비용

(5, 8+10+5)을 보면

5는 처음에 임시로 바꾸는데 드는 힘

8+10+5 는 바꿔야 할 부분의 힘의 총합



그리고 마지막으로 (cnt+1) * total_min을 더해줘야 하는데

여기서 cnt+1의 의미는

처음에 임시로 옮겨주는 1번 

그리고 교환 갯수만큼 사용되는 데 cnt번 해서 총 (cnt+1)이다.



​따라서 전체를 탐색하면서

1)과 2)중 최솟값을 선택해서 계속 누적하면 된다.